<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6-Camera Extrinsic Calibration</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 66.66%;
            overflow: hidden;
            background: #000;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .img-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        const PORTS = ["port_2", "port_1", "port_5", "port_3", "port_7", "port_6"];
        const PORT_NAMES = {
            "port_1": "Front (1)",
            "port_2": "Front Left (2)",
            "port_3": "Rear Left (3)",
            "port_5": "Front Right (5)",
            "port_6": "Rear Right (6)",
            "port_7": "Rear (7)"
        };

        // Math Utils
        function toRadians(deg) { return deg * Math.PI / 180; }

        function getRotationMatrix(roll, pitch, yaw) {
            const r = toRadians(roll);
            const p = toRadians(pitch);
            const y = toRadians(yaw);

            const cx = Math.cos(r), sx = Math.sin(r);
            const cy = Math.cos(p), sy = Math.sin(p);
            const cz = Math.cos(y), sz = Math.sin(y);

            // Rz * Ry * Rx
            const Rz = [
                [cz, -sz, 0],
                [sz, cz, 0],
                [0, 0, 1]
            ];
            const Ry = [
                [cy, 0, sy],
                [0, 1, 0],
                [-sy, 0, cy]
            ];
            const Rx = [
                [1, 0, 0],
                [0, cx, -sx],
                [0, sx, cx]
            ];

            // R = Rz * Ry * Rx
            const RyRx = [
                [cy, sy * sx, sy * cx],
                [0, cx, -sx],
                [-sy, cy * sx, cy * cx]
            ];

            const R = [
                [
                    cz * RyRx[0][0] + -sz * RyRx[1][0] + 0 * RyRx[2][0],
                    cz * RyRx[0][1] + -sz * RyRx[1][1] + 0 * RyRx[2][1],
                    cz * RyRx[0][2] + -sz * RyRx[1][2] + 0 * RyRx[2][2]
                ],
                [
                    sz * RyRx[0][0] + cz * RyRx[1][0] + 0 * RyRx[2][0],
                    sz * RyRx[0][1] + cz * RyRx[1][1] + 0 * RyRx[2][1],
                    sz * RyRx[0][2] + cz * RyRx[1][2] + 0 * RyRx[2][2]
                ],
                [
                    0 * RyRx[0][0] + 0 * RyRx[1][0] + 1 * RyRx[2][0],
                    0 * RyRx[0][1] + 0 * RyRx[1][1] + 1 * RyRx[2][1],
                    0 * RyRx[0][2] + 0 * RyRx[1][2] + 1 * RyRx[2][2]
                ]
            ];
            return R;
        }

        function projectPoint(point, R, t, K, dist) {
            const x = R[0][0] * point[0] + R[0][1] * point[1] + R[0][2] * point[2] + t[0];
            const y = R[1][0] * point[0] + R[1][1] * point[1] + R[1][2] * point[2] + t[1];
            const z = R[2][0] * point[0] + R[2][1] * point[1] + R[2][2] * point[2] + t[2];

            if (z < 0.1) return null;

            const x_n = x / z;
            const y_n = y / z;

            const r2 = x_n * x_n + y_n * y_n;
            const k1 = dist.k1 || 0;
            const k2 = dist.k2 || 0;
            const radial = 1 + k1 * r2 + k2 * r2 * r2;

            const x_d = x_n * radial;
            const y_d = y_n * radial;

            const u = K.fx * x_d + K.cx;
            const v = K.fy * y_d + K.cy;

            return [u, v];
        }

        // CameraView Component (Handles rendering and interaction for a single camera)
        const CameraView = React.memo(({ port, frame, scene, config, points, showPoints, onExpand, isSingleView, onSelect }) => {
            const canvasRef = useRef(null);
            const [transform, setTransform] = useState({ k: 1, x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const dragStart = useRef({ x: 0, y: 0 });

            // Reset transform when switching views or ports, but NOT when just updating config/points
            useEffect(() => {
                if (!isSingleView) {
                    setTransform({ k: 1, x: 0, y: 0 });
                }
            }, [isSingleView]);

            // LiDAR Rendering Logic
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Resize canvas if needed
                if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (!config || !points || points.length === 0 || !showPoints) return;

                // Optimization: Use ImageData
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;

                const camConfig = config.cameras[port];
                const R = getRotationMatrix(camConfig.extrinsic.roll, camConfig.extrinsic.pitch, camConfig.extrinsic.yaw);
                const t = [camConfig.extrinsic.x, camConfig.extrinsic.y, camConfig.extrinsic.z];
                const K = camConfig.intrinsic;
                const dist = camConfig.intrinsic;

                const scaleX = canvas.width / 1920;
                const scaleY = canvas.height / 1280;

                for (let i = 0; i < points.length; i++) {
                    const pt = points[i];
                    const z = R[2][0] * pt[0] + R[2][1] * pt[1] + R[2][2] * pt[2] + t[2];

                    if (z < 0.1) continue;

                    const uv = projectPoint(pt, R, t, K, dist);
                    if (uv) {
                        const u = Math.floor(uv[0] * scaleX);
                        const v = Math.floor(uv[1] * scaleY);

                        if (u >= 0 && u < canvas.width && v >= 0 && v < canvas.height) {
                            const minDepth = -2.0;
                            const maxDepth = 5.0;
                            const pointZ = pt[2];
                            const hue = (1.0 - (Math.max(minDepth, Math.min(pointZ, maxDepth)) - minDepth) / (maxDepth - minDepth)) * 240;

                            // Simple HSL to RGB
                            const h = hue;
                            const s = 1.0;
                            const l = 0.5;
                            const c = (1 - Math.abs(2 * l - 1)) * s;
                            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                            const m = l - c / 2;
                            let r = 0, g = 0, b = 0;

                            if (0 <= h && h < 60) { r = c; g = x; b = 0; }
                            else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
                            else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
                            else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
                            else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
                            else if (300 <= h && h < 360) { r = c; g = 0; b = x; }

                            r = Math.round((r + m) * 255);
                            g = Math.round((g + m) * 255);
                            b = Math.round((b + m) * 255);

                            const setPixel = (x, y) => {
                                if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                                    const idx = (y * canvas.width + x) * 4;
                                    data[idx] = r;
                                    data[idx + 1] = g;
                                    data[idx + 2] = b;
                                    data[idx + 3] = 255;
                                }
                            };

                            setPixel(u, v);
                            setPixel(u + 1, v);
                            setPixel(u, v + 1);
                            setPixel(u + 1, v + 1);
                        }
                    }
                }
                ctx.putImageData(imageData, 0, 0);

            }, [config, points, showPoints, port]); // Only re-render when data changes, NOT on transform

            // Interaction Handlers
            const handleWheel = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                const scaleAmount = -e.deltaY * 0.001;
                setTransform(t => {
                    const newScale = Math.max(1, Math.min(t.k * (1 + scaleAmount), 10));
                    return { ...t, k: newScale };
                });
            }, []);

            const handleMouseDown = useCallback((e) => {
                if (e.button !== 0) return; // Only left click
                setIsDragging(true);
                dragStart.current = { x: e.clientX - transform.x, y: e.clientY - transform.y };
                if (onSelect) onSelect();
            }, [transform, onSelect]);

            const handleMouseMove = useCallback((e) => {
                if (!isDragging) return;
                e.preventDefault();
                setTransform(t => ({
                    ...t,
                    x: e.clientX - dragStart.current.x,
                    y: e.clientY - dragStart.current.y
                }));
            }, [isDragging]);

            const handleMouseUp = useCallback(() => {
                setIsDragging(false);
            }, []);

            return (
                <div
                    className={`relative overflow-hidden cursor-move select-none ${isSingleView ? 'w-full h-full' : 'border-2 border-gray-700 rounded aspect-[3/2]'}`}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    ref={el => {
                        if (el) el.onwheel = handleWheel; // Native event for passive listener issue
                    }}
                >
                    <div
                        style={{
                            transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.k})`,
                            transformOrigin: '0 0',
                            width: '100%',
                            height: '100%',
                            transition: isDragging ? 'none' : 'transform 0.1s ease-out'
                        }}
                        className="relative w-full h-full flex items-center justify-center"
                    >
                        <div className="relative w-full h-full">
                            <img src={`/api/image/${port}/${frame}?scene=${scene}`} className="img-bg w-full h-full object-contain" draggable="false" />
                            <canvas ref={canvasRef} className="canvas-overlay w-full h-full" />
                        </div>
                    </div>

                    {/* Overlay UI */}
                    <div className="absolute top-0 left-0 bg-black/50 px-2 py-1 z-50 flex justify-between w-full pointer-events-auto" onMouseDown={e => e.stopPropagation()}>
                        <span className="text-white text-sm font-bold shadow-black drop-shadow-md">{PORT_NAMES[port]}</span>
                        {!isSingleView && onExpand && (
                            <button
                                className="bg-blue-500/80 hover:bg-blue-500 px-2 rounded text-xs text-white pointer-events-auto"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onExpand();
                                }}
                            >
                                Expand
                            </button>
                        )}
                        {isSingleView && (
                            <div className="text-xs text-gray-300 ml-2">
                                Zoom: {transform.k.toFixed(1)}x
                            </div>
                        )}
                    </div>
                </div>
            );
        });

        // Three.js LiDAR Viewer Component
        const LidarViewer = React.memo(({ points }) => {
            const mountRef = useRef(null);

            useEffect(() => {
                if (!mountRef.current) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);

                const camera = new THREE.PerspectiveCamera(75, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
                camera.position.set(0, 0, 20);
                camera.up.set(0, 0, 1);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                mountRef.current.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                const gridHelper = new THREE.GridHelper(100, 100);
                gridHelper.rotation.x = Math.PI / 2;
                scene.add(gridHelper);
                const axesHelper = new THREE.AxesHelper(5);
                scene.add(axesHelper);

                let pointsGeometry = new THREE.BufferGeometry();
                const vertices = new Float32Array(points.flat());
                pointsGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

                // Color by Z height (Shared logic)
                const colors = [];
                const color = new THREE.Color();
                for (let i = 0; i < points.length; i++) {
                    const z = points[i][2];
                    // Map Z -2 to 5m to color (Same as 2D view)
                    const minDepth = -2.0;
                    const maxDepth = 5.0;
                    const t = (Math.max(minDepth, Math.min(z, maxDepth)) - minDepth) / (maxDepth - minDepth);
                    color.setHSL(0.6 - t * 0.6, 1.0, 0.5); // Blue to Red
                    colors.push(color.r, color.g, color.b);
                }
                pointsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const pointsMaterial = new THREE.PointsMaterial({ size: 0.15, vertexColors: true }); // Increased size
                const pointCloud = new THREE.Points(pointsGeometry, pointsMaterial);
                scene.add(pointCloud);

                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                const handleResize = () => {
                    if (!mountRef.current) return;
                    camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('resize', handleResize);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    pointsGeometry.dispose();
                    pointsMaterial.dispose();
                };
            }, [points]);

            return <div ref={mountRef} className="w-full h-full" />;
        });

        function App() {
            const [scenes, setScenes] = useState([]);
            const [currentScene, setCurrentScene] = useState("");
            const [frames, setFrames] = useState([]);
            const [currentFrame, setCurrentFrame] = useState("");
            const [config, setConfig] = useState(null);
            const [selectedPort, setSelectedPort] = useState("port_1");
            const [points3D, setPoints3D] = useState([]);
            const [showPoints, setShowPoints] = useState(true);

            const [viewMode, setViewMode] = useState('grid');

            // Playback State
            const [isPlaying, setIsPlaying] = useState(false);
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

            useEffect(() => {
                fetch('/api/scenes').then(res => res.json()).then(data => {
                    setScenes(data.scenes);
                    setCurrentScene(data.current);
                    fetchData();
                });
            }, []);

            const fetchData = () => {
                const t = Date.now();
                fetch(`/api/frames?t=${t}`).then(res => res.json()).then(data => {
                    setFrames(data);
                    if (data.length > 0) setCurrentFrame(data[0]);
                    else setCurrentFrame("");
                });
                fetch(`/api/config?t=${t}`).then(res => res.json()).then(setConfig);
            };

            const handleSceneChange = (scene) => {
                const switchScene = () => {
                    fetch('/api/scene', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ scene })
                    }).then(res => res.json()).then(data => {
                        setCurrentScene(data.current);
                        setHasUnsavedChanges(false);
                        fetchData();
                    });
                };

                if (hasUnsavedChanges) {
                    if (confirm("You have unsaved changes. Click OK to Save and Switch, or Cancel to Switch without saving.")) {
                        saveConfig().then(() => switchScene());
                    } else {
                        switchScene();
                    }
                } else {
                    switchScene();
                }
            };

            useEffect(() => {
                if (currentFrame) {
                    setPoints3D([]);
                    fetch(`/api/points/${currentFrame}?scene=${currentScene}`)
                        .then(res => res.json())
                        .then(data => setPoints3D(data.points));
                } else {
                    setPoints3D([]);
                }
            }, [currentFrame, currentScene]);

            // Playback Logic
            useEffect(() => {
                let interval;
                if (isPlaying && frames.length > 0) {
                    interval = setInterval(() => {
                        setCurrentFrame(prev => {
                            const idx = frames.indexOf(prev);
                            const nextIdx = (idx + 1) % frames.length;
                            return frames[nextIdx];
                        });
                    }, 100); // 10 FPS
                }
                return () => clearInterval(interval);
            }, [isPlaying, frames]);

            const handleConfigChange = (port, key, value) => {
                const newConfig = { ...config };
                newConfig.cameras[port].extrinsic[key] = parseFloat(value);
                setConfig(newConfig);
                setHasUnsavedChanges(true);
            };

            const saveConfig = () => {
                return fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                }).then(() => {
                    alert("Saved!");
                    setHasUnsavedChanges(false);
                });
            };

            if (!config) return <div>Loading config...</div>;

            return (
                <div className="flex h-screen flex-col">
                    <div className="bg-gray-800 p-4 flex items-center gap-4">
                        <h1 className="text-xl font-bold">Calibration Tool (Fast)</h1>

                        <div className="flex items-center gap-2 bg-gray-700 p-1 rounded">
                            <span className="text-xs text-gray-400 pl-1">Scene:</span>
                            <select
                                className="bg-gray-600 p-1 rounded text-sm"
                                value={currentScene}
                                onChange={e => handleSceneChange(e.target.value)}
                            >
                                {scenes.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                        </div>

                        <select className="bg-gray-700 p-2 rounded" value={currentFrame} onChange={e => setCurrentFrame(e.target.value)}>
                            {frames.map(f => <option key={f} value={f}>{f}</option>)}
                        </select>

                        {/* Playback Controls */}
                        <div className="flex gap-1">
                            <button className="bg-gray-600 hover:bg-gray-500 px-2 py-1 rounded" onClick={() => {
                                const idx = frames.indexOf(currentFrame);
                                if (idx > 0) setCurrentFrame(frames[idx - 1]);
                            }}>Prev</button>
                            <button className={`px-2 py-1 rounded ${isPlaying ? 'bg-red-600' : 'bg-green-600'}`} onClick={() => setIsPlaying(!isPlaying)}>
                                {isPlaying ? 'Pause' : 'Play'}
                            </button>
                            <button className="bg-gray-600 hover:bg-gray-500 px-2 py-1 rounded" onClick={() => {
                                const idx = frames.indexOf(currentFrame);
                                if (idx < frames.length - 1) setCurrentFrame(frames[idx + 1]);
                            }}>Next</button>
                        </div>

                        <button className="bg-blue-600 px-4 py-2 rounded" onClick={saveConfig}>Save Config</button>
                        <label className="flex items-center gap-2">
                            <input type="checkbox" checked={showPoints} onChange={e => setShowPoints(e.target.checked)} />
                            Show LiDAR
                        </label>

                        <div className="ml-auto flex gap-2">
                            {viewMode !== 'grid' && (
                                <button className="bg-gray-600 px-4 py-2 rounded" onClick={() => setViewMode('grid')}>
                                    Back to Grid
                                </button>
                            )}
                            {viewMode !== 'lidar' && (
                                <button className="bg-purple-600 px-4 py-2 rounded" onClick={() => setViewMode('lidar')}>
                                    LiDAR View
                                </button>
                            )}
                        </div>
                    </div >

                    <div className="flex flex-1 overflow-hidden">
                        <div className={`flex-1 overflow-hidden p-4 relative bg-black flex items-center justify-center`}>

                            {viewMode === 'grid' && (
                                <div className="grid grid-cols-3 gap-4 w-full h-full overflow-y-auto">
                                    {PORTS.map(port => (
                                        <div key={port} className={`relative flex flex-col ${selectedPort === port ? 'ring-2 ring-blue-500' : ''}`}>
                                            <CameraView
                                                port={port}
                                                frame={currentFrame}
                                                scene={currentScene}
                                                config={config}
                                                points={points3D}
                                                showPoints={showPoints}
                                                onExpand={() => {
                                                    setSelectedPort(port);
                                                    setViewMode('single');
                                                }}
                                                onSelect={() => setSelectedPort(port)}
                                                isSingleView={false}
                                            />
                                        </div>
                                    ))}
                                </div>
                            )}

                            {viewMode === 'single' && (
                                <div className="w-full h-full">
                                    <CameraView
                                        port={selectedPort}
                                        frame={currentFrame}
                                        scene={currentScene}
                                        config={config}
                                        points={points3D}
                                        showPoints={showPoints}
                                        isSingleView={true}
                                    />
                                </div>
                            )}

                            {viewMode === 'lidar' && (
                                <LidarViewer points={points3D} />
                            )}
                        </div>

                        {viewMode !== 'lidar' && (
                            <div className="w-80 bg-gray-900 p-4 overflow-y-auto border-l border-gray-700 z-20">
                                <h2 className="text-lg font-bold mb-4">Adjust {PORT_NAMES[selectedPort]}</h2>

                                <div className="space-y-4">
                                    {['x', 'y', 'z', 'roll', 'pitch', 'yaw'].map(param => (
                                        <div key={param}>
                                            <div className="flex justify-between text-sm">
                                                <span>{param.toUpperCase()}</span>
                                                <span>{config.cameras[selectedPort].extrinsic[param].toFixed(3)}</span>
                                            </div>
                                            <input
                                                type="range"
                                                min={['roll', 'pitch', 'yaw'].includes(param) ? -180 : -5}
                                                max={['roll', 'pitch', 'yaw'].includes(param) ? 180 : 5}
                                                step={['roll', 'pitch', 'yaw'].includes(param) ? 0.1 : 0.01}
                                                value={config.cameras[selectedPort].extrinsic[param]}
                                                onChange={e => handleConfigChange(selectedPort, param, e.target.value)}
                                                className="w-full"
                                            />
                                        </div>
                                    ))}
                                </div>

                                <div className="mt-8">
                                    <h3 className="font-bold mb-2">Intrinsics (Read-only)</h3>
                                    <pre className="text-xs bg-gray-800 p-2 rounded">
                                        {JSON.stringify(config.cameras[selectedPort].intrinsic, null, 2)}
                                    </pre>
                                </div>
                            </div>
                        )}
                    </div>
                </div >
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>